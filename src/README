Gavenea Maria-Laurentia
321CA

					                   README

The program runs as follows:

- Main - the input data is read with the help of a GameInputLoader object (gameInputLoader)
		 and stored in a GameInput object (gameInput)
	   - the input data from gameInput object is stored in HeroesFactory singleton, in Game object
	    (game), in GameMap singleton and in AngelsFactory object (angelsFactory)
	   - the game starts by using the method startGame() of game object

- Game
		- startGame() method:
			- for each round:
			    - applies overtime damage on heroes (using a Fight object)
			    - applies strategies for each hero (using an ExecuteStrategies object)
				- moves heroes (using a MoveHeroes object)
				- makes heroes fight and apply changes to the heroes (using a Fight object)
				- makes angels appear on map (using an AngelsFactory object) and makes them interact
				with heroes

			- here appear three types of observers depending on the subject they observe:
			    - one that observes game object (greatMagiciansObsForGame)
			    - one that observes fight object (greatMagiciansObsForFight)
			    - one that observes angel object (greatMagiciansObsForAngel)
			- all these observers:
			    - are notified by the subjects about changes that appear during the game
			    - they print information about these changes

			- prints output (for each round and final results)

- ExecuteStrategies
        - executeStrategies() method:
            - makes heroes choose their strategies and apply them (using Strategy Pattern)

- MoveHeroes
		- move() method:
			- moves each hero alive using moveHero() method

			- moveHero() method:
				- moves a hero if he can move, and choose the direction with a static method
				(chooseDir()) from ChooseDirection class

- Fight
		- applyOvertimeDamages() method:
				- for each hero applies overtime damage for current round

		- chooseFightersAndFight() method:
				- determines which heroes fights
				- using fight() method, it makes two heroes fight and get damaged
				- using computeNewInfoForWinners() method:
						- for winners, it computes new info such as: - XP
																	 - level
																	 - HP (if level up)


Additional information:

First stage of project:

Double Dispatch concept:
	I used this concept thinking that an ability can be used against a hero, so:
		- I made two interfaces:
				- MortalHero - that is implemented by heroes who can be damaged (abilities have
				 effect on them)
				- Ability - that is implemented by abilities that have effects on MortalHero heroes

		- MortalHero
			- this type of heroes must implement method getDamagedBy(Ability attackerAbility,
			 Hero attacker)
			- Knight, Pyromancer, Rogue and Wizard implement this interface

		- Ability
			- this type of abilities must implement
					- four methods of form: applyAbility(AttackedType attacked, Hero attacker),
					 for each hero that implements MortalHero interface
					- one method: getTotalDamageForWizard(Hero wizard, Hero otherHero)
			- Knight's, Pyromancer's, Rogue's and Wizard's abilities implement this interface


Second stage of project:

Strategy Pattern:
    I used this pattern thinking that there are two types of strategies that heroes can adopt:
        - defense (they increase their hp and decrease their modifiers)
        - offense (they decrease their hp and increase their modifiers)
    I made two classes that implements Strategy interface:
        - DefenseStrategy
        - OffenseStrategy
    I made a class Context
        - it has a constructor that receives a strategy object as parameter
        - it has a method that executes that strategy

Visitor Pattern:
    I used this pattern thinking that an angel influences a hero, so:
        I made an interface (VisitedbyAngel) that is implemented by al heroes:
            - they must implement method acceptVisit(Angel angel)

        I made an Angel abstract class which all angels inherit:
            - they must implement 4 methods of form influenceHero(Hero hero), for each type of hero

Observer Pattern:
    I used this pattern as follows:
        I made:
            - a GreatMagician class that inherit Observer abstract class
                - it has a constructor that receives as parameter a subject object
                - in this constructor the subject attaches to it's list of observers the current
                observer
                - it implements update(message) method that prints the message

            - a Subject class
                - has a method setMessage(message) that receives a message and notifies all its
                observers that the message changed
                - Game, Fight and Angel classes extend this class
